{"ast":null,"code":"import { defineComponent, inject, ref, shallowRef, computed, watch, onMounted, onUpdated, triggerRef, createVNode, nextTick } from 'vue';\nimport { useDocumentVisibility, useWindowFocus, useResizeObserver } from '@vueuse/core';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue';\nimport TabBar from './tab-bar2.mjs';\nimport { tabsRootContextKey } from './constants.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\nimport { mutable } from '../../../utils/typescript.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { capitalize } from '../../../utils/strings.mjs';\nconst tabNavProps = buildProps({\n  panes: {\n    type: definePropType(Array),\n    default: () => mutable([])\n  },\n  currentName: {\n    type: [String, Number],\n    default: \"\"\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    default: \"\"\n  },\n  stretch: Boolean\n});\nconst tabNavEmits = {\n  tabClick: (tab, tabName, ev) => ev instanceof Event,\n  tabRemove: (tab, ev) => ev instanceof Event\n};\nconst COMPONENT_NAME = \"ElTabNav\";\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup(props, {\n    expose,\n    emit\n  }) {\n    const rootTabs = inject(tabsRootContextKey);\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`);\n    const ns = useNamespace(\"tabs\");\n    const visibility = useDocumentVisibility();\n    const focused = useWindowFocus();\n    const navScroll$ = ref();\n    const nav$ = ref();\n    const el$ = ref();\n    const tabRefsMap = ref({});\n    const tabBarRef = ref();\n    const scrollable = ref(false);\n    const navOffset = ref(0);\n    const isFocus = ref(false);\n    const focusable = ref(true);\n    const tracker = shallowRef();\n    const sizeName = computed(() => [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\");\n    const navStyle = computed(() => {\n      const dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`\n      };\n    });\n    const scrollPrev = () => {\n      if (!navScroll$.value) return;\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      const newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return;\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      const newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value;\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return;\n      await nextTick();\n      const activeTab = tabRefsMap.value[props.currentName];\n      if (!activeTab) return;\n      const navScroll = navScroll$.value;\n      const isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n      const activeTabBounding = activeTab.getBoundingClientRect();\n      const navScrollBounding = navScroll.getBoundingClientRect();\n      const maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n      const currentOffset = navOffset.value;\n      let newOffset = currentOffset;\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n        }\n      }\n      newOffset = Math.max(newOffset, 0);\n      navOffset.value = Math.min(newOffset, maxOffset);\n    };\n    const update = () => {\n      var _a;\n      if (!nav$.value || !navScroll$.value) return;\n      props.stretch && ((_a = tabBarRef.value) == null ? void 0 : _a.update());\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`];\n      const containerSize = navScroll$.value[`offset${capitalize(sizeName.value)}`];\n      const currentOffset = navOffset.value;\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset;\n        scrollable.value.next = currentOffset + containerSize < navSize;\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n    const changeTab = event => {\n      let step = 0;\n      switch (event.code) {\n        case EVENT_CODE.left:\n        case EVENT_CODE.up:\n          step = -1;\n          break;\n        case EVENT_CODE.right:\n        case EVENT_CODE.down:\n          step = 1;\n          break;\n        default:\n          return;\n      }\n      const tabList = Array.from(event.currentTarget.querySelectorAll(\"[role=tab]:not(.is-disabled)\"));\n      const currentIndex = tabList.indexOf(event.target);\n      let nextIndex = currentIndex + step;\n      if (nextIndex < 0) {\n        nextIndex = tabList.length - 1;\n      } else if (nextIndex >= tabList.length) {\n        nextIndex = 0;\n      }\n      tabList[nextIndex].focus({\n        preventScroll: true\n      });\n      tabList[nextIndex].click();\n      setFocus();\n    };\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true;\n    };\n    const removeFocus = () => isFocus.value = false;\n    const setRefs = (el, key) => {\n      tabRefsMap.value[key] = el;\n    };\n    const focusActiveTab = async () => {\n      await nextTick();\n      const activeTab = tabRefsMap.value[props.currentName];\n      activeTab == null ? void 0 : activeTab.focus({\n        preventScroll: true\n      });\n    };\n    watch(visibility, visibility2 => {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(() => focusable.value = true, 50);\n      }\n    });\n    watch(focused, focused2 => {\n      if (focused2) {\n        setTimeout(() => focusable.value = true, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    useResizeObserver(el$, update);\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0));\n    onUpdated(() => update());\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n      focusActiveTab,\n      tabListRef: nav$,\n      tabBarRef,\n      scheduleRender: () => triggerRef(tracker)\n    });\n    return () => {\n      const scrollBtn = scrollable.value ? [createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-prev\"), ns.is(\"disabled\", !scrollable.value.prev)],\n        \"onClick\": scrollPrev\n      }, [createVNode(ElIcon, null, {\n        default: () => [createVNode(ArrowLeft, null, null)]\n      })]), createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-next\"), ns.is(\"disabled\", !scrollable.value.next)],\n        \"onClick\": scrollNext\n      }, [createVNode(ElIcon, null, {\n        default: () => [createVNode(ArrowRight, null, null)]\n      })])] : null;\n      const tabs = props.panes.map((pane, index) => {\n        var _a, _b, _c, _d;\n        const uid = pane.uid;\n        const disabled = pane.props.disabled;\n        const tabName = (_b = (_a = pane.props.name) != null ? _a : pane.index) != null ? _b : `${index}`;\n        const closable = !disabled && (pane.isClosable || props.editable);\n        pane.index = `${index}`;\n        const btnClose = closable ? createVNode(ElIcon, {\n          \"class\": \"is-icon-close\",\n          \"onClick\": ev => emit(\"tabRemove\", pane, ev)\n        }, {\n          default: () => [createVNode(Close, null, null)]\n        }) : null;\n        const tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;\n        const tabindex = !disabled && pane.active ? 0 : -1;\n        return createVNode(\"div\", {\n          \"ref\": el => setRefs(el, tabName),\n          \"class\": [ns.e(\"item\"), ns.is(rootTabs.props.tabPosition), ns.is(\"active\", pane.active), ns.is(\"disabled\", disabled), ns.is(\"closable\", closable), ns.is(\"focus\", isFocus.value)],\n          \"id\": `tab-${tabName}`,\n          \"key\": `tab-${uid}`,\n          \"aria-controls\": `pane-${tabName}`,\n          \"role\": \"tab\",\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex,\n          \"onFocus\": () => setFocus(),\n          \"onBlur\": () => removeFocus(),\n          \"onClick\": ev => {\n            removeFocus();\n            emit(\"tabClick\", pane, tabName, ev);\n          },\n          \"onKeydown\": ev => {\n            if (closable && (ev.code === EVENT_CODE.delete || ev.code === EVENT_CODE.backspace)) {\n              emit(\"tabRemove\", pane, ev);\n            }\n          }\n        }, [...[tabLabelContent, btnClose]]);\n      });\n      tracker.value;\n      return createVNode(\"div\", {\n        \"ref\": el$,\n        \"class\": [ns.e(\"nav-wrap\"), ns.is(\"scrollable\", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]\n      }, [scrollBtn, createVNode(\"div\", {\n        \"class\": ns.e(\"nav-scroll\"),\n        \"ref\": navScroll$\n      }, [props.panes.length > 0 ? createVNode(\"div\", {\n        \"class\": [ns.e(\"nav\"), ns.is(rootTabs.props.tabPosition), ns.is(\"stretch\", props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition))],\n        \"ref\": nav$,\n        \"style\": navStyle.value,\n        \"role\": \"tablist\",\n        \"onKeydown\": changeTab\n      }, [...[!props.type ? createVNode(TabBar, {\n        \"ref\": tabBarRef,\n        \"tabs\": [...props.panes],\n        \"tabRefs\": tabRefsMap.value\n      }, null) : null, tabs]]) : null])]);\n    };\n  }\n});\nexport { TabNav as default, tabNavEmits, tabNavProps };","map":{"version":3,"names":["tabNavProps","buildProps","panes","type","definePropType","Array","default","mutable","currentName","String","Number","editable","Boolean","values","stretch","tabNavEmits","tabClick","tab","tabName","ev","Event","tabRemove","COMPONENT_NAME","TabNav","defineComponent","name","props","emits","expose","emit","rootTabs","inject","tabsRootContextKey","throwError","ns","useNamespace","visibility","useDocumentVisibility","focused","useWindowFocus","navScroll$","ref","nav$","el$","tabRefsMap","tabBarRef","scrollable","navOffset","isFocus","focusable","tracker","shallowRef","sizeName","computed","includes","tabPosition","navStyle","dir","value","transform","containerSize","capitalize","currentOffset","newOffset","scrollNext","navSize","scrollToActiveTab","nav","nextTick","activeTab","navScroll","isHorizontal","activeTabBounding","getBoundingClientRect","navScrollBounding","left","right","top","bottom","Math","min","maxOffset","update","_a","prev","next","changeTab","event","step","code","EVENT_CODE","up","down","tabList","from","currentTarget","querySelectorAll","currentIndex","indexOf","target","nextIndex","length","focus","preventScroll","setFocus","removeFocus","setRefs","el","key","focusActiveTab","watch","visibility2","setTimeout","focused2","useResizeObserver","onUpdated","tabListRef","scheduleRender","triggerRef","scrollBtn","createVNode","e","is","scrollPrev","ElIcon","ArrowLeft","ArrowRight","tabs","map","pane","index","_b","_c","_d","uid","disabled","closable","isClosable","btnClose","Close","tabLabelContent","slots","label","call","tabindex","active","onFocus","onBlur","delete","backspace","TabBar"],"sources":["../../../../../../packages/components/tabs/src/tab-nav.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  inject,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  shallowRef,\n  triggerRef,\n  watch,\n} from 'vue'\nimport {\n  useDocumentVisibility,\n  useResizeObserver,\n  useWindowFocus,\n} from '@vueuse/core'\nimport {\n  buildProps,\n  capitalize,\n  definePropType,\n  mutable,\n  throwError,\n} from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport TabBar from './tab-bar.vue'\nimport { tabsRootContextKey } from './constants'\n\nimport type {\n  CSSProperties,\n  ComponentPublicInstance,\n  ExtractPropTypes,\n  __ExtractPublicPropTypes,\n} from 'vue'\nimport type { TabBarInstance } from './tab-bar'\nimport type { TabPaneName, TabsPaneContext } from './constants'\n\ninterface Scrollable {\n  next?: boolean\n  prev?: number\n}\n\nexport const tabNavProps = buildProps({\n  panes: {\n    type: definePropType<TabsPaneContext[]>(Array),\n    default: () => mutable([] as const),\n  },\n  currentName: {\n    type: [String, Number],\n    default: '',\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  stretch: Boolean,\n} as const)\n\nexport const tabNavEmits = {\n  tabClick: (tab: TabsPaneContext, tabName: TabPaneName, ev: Event) =>\n    ev instanceof Event,\n  tabRemove: (tab: TabsPaneContext, ev: Event) => ev instanceof Event,\n}\n\nexport type TabNavProps = ExtractPropTypes<typeof tabNavProps>\nexport type TabNavPropsPublic = __ExtractPublicPropTypes<typeof tabNavProps>\nexport type TabNavEmits = typeof tabNavEmits\n\nconst COMPONENT_NAME = 'ElTabNav'\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup(props, { expose, emit }) {\n    const rootTabs = inject(tabsRootContextKey)\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`)\n\n    const ns = useNamespace('tabs')\n    const visibility = useDocumentVisibility()\n    const focused = useWindowFocus()\n\n    const navScroll$ = ref<HTMLDivElement>()\n    const nav$ = ref<HTMLDivElement>()\n    const el$ = ref<HTMLDivElement>()\n    const tabRefsMap = ref<{ [key: TabPaneName]: HTMLDivElement }>({})\n\n    const tabBarRef = ref<TabBarInstance>()\n\n    const scrollable = ref<false | Scrollable>(false)\n    const navOffset = ref(0)\n    const isFocus = ref(false)\n    const focusable = ref(true)\n    const tracker = shallowRef()\n\n    const sizeName = computed(() =>\n      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n        ? 'width'\n        : 'height'\n    )\n    const navStyle = computed<CSSProperties>(() => {\n      const dir = sizeName.value === 'width' ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`,\n      }\n    })\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return\n\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (!currentOffset) return\n\n      const newOffset =\n        currentOffset > containerSize ? currentOffset - containerSize : 0\n\n      navOffset.value = newOffset\n    }\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset =\n        navSize - currentOffset > containerSize * 2\n          ? currentOffset + containerSize\n          : navSize - containerSize\n\n      navOffset.value = newOffset\n    }\n\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return\n\n      await nextTick()\n\n      const activeTab = tabRefsMap.value[props.currentName]\n      if (!activeTab) return\n\n      const navScroll = navScroll$.value\n      const isHorizontal = ['top', 'bottom'].includes(\n        rootTabs.props.tabPosition\n      )\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = navOffset.value\n      let newOffset = currentOffset\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset =\n            currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset =\n            currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset =\n            currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset =\n            currentOffset +\n            (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      navOffset.value = Math.min(newOffset, maxOffset)\n    }\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return\n\n      props.stretch && tabBarRef.value?.update()\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {}\n        scrollable.value.prev = currentOffset\n        scrollable.value.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize\n        }\n      } else {\n        scrollable.value = false\n        if (currentOffset > 0) {\n          navOffset.value = 0\n        }\n      }\n    }\n\n    const changeTab = (event: KeyboardEvent) => {\n      let step = 0\n\n      switch (event.code) {\n        case EVENT_CODE.left:\n        case EVENT_CODE.up:\n          step = -1\n          break\n        case EVENT_CODE.right:\n        case EVENT_CODE.down:\n          step = 1\n          break\n        default:\n          return\n      }\n\n      const tabList = Array.from(\n        (\n          event.currentTarget as HTMLDivElement\n        ).querySelectorAll<HTMLDivElement>('[role=tab]:not(.is-disabled)')\n      )\n      const currentIndex = tabList.indexOf(event.target as HTMLDivElement)\n      let nextIndex = currentIndex + step\n\n      if (nextIndex < 0) {\n        nextIndex = tabList.length - 1\n      } else if (nextIndex >= tabList.length) {\n        nextIndex = 0\n      }\n\n      tabList[nextIndex].focus({ preventScroll: true }) // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      setFocus()\n    }\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true\n    }\n    const removeFocus = () => (isFocus.value = false)\n\n    const setRefs = (\n      el: Element | ComponentPublicInstance | null,\n      key: TabPaneName\n    ) => {\n      tabRefsMap.value[key] = el as HTMLDivElement\n    }\n\n    const focusActiveTab = async () => {\n      await nextTick()\n\n      const activeTab = tabRefsMap.value[props.currentName]\n      activeTab?.focus({ preventScroll: true })\n    }\n\n    watch(visibility, (visibility) => {\n      if (visibility === 'hidden') {\n        focusable.value = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => (focusable.value = true), 50)\n      }\n    })\n    watch(focused, (focused) => {\n      if (focused) {\n        setTimeout(() => (focusable.value = true), 50)\n      } else {\n        focusable.value = false\n      }\n    })\n\n    useResizeObserver(el$, update)\n\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0))\n    onUpdated(() => update())\n\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n      focusActiveTab,\n      tabListRef: nav$,\n      tabBarRef,\n      scheduleRender: () => triggerRef(tracker),\n    })\n\n    return () => {\n      const scrollBtn = scrollable.value\n        ? [\n            <span\n              class={[\n                ns.e('nav-prev'),\n                ns.is('disabled', !scrollable.value.prev),\n              ]}\n              onClick={scrollPrev}\n            >\n              <ElIcon>\n                <ArrowLeft />\n              </ElIcon>\n            </span>,\n            <span\n              class={[\n                ns.e('nav-next'),\n                ns.is('disabled', !scrollable.value.next),\n              ]}\n              onClick={scrollNext}\n            >\n              <ElIcon>\n                <ArrowRight />\n              </ElIcon>\n            </span>,\n          ]\n        : null\n\n      const tabs = props.panes.map((pane, index) => {\n        const uid = pane.uid\n        const disabled = pane.props.disabled\n        const tabName = pane.props.name ?? pane.index ?? `${index}`\n        const closable = !disabled && (pane.isClosable || props.editable)\n        pane.index = `${index}`\n\n        const btnClose = closable ? (\n          <ElIcon\n            class=\"is-icon-close\"\n            // `onClick` not exist when generate dts\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            onClick={(ev: MouseEvent) => emit('tabRemove', pane, ev)}\n          >\n            <Close />\n          </ElIcon>\n        ) : null\n\n        const tabLabelContent = pane.slots.label?.() || pane.props.label\n        const tabindex = !disabled && pane.active ? 0 : -1\n\n        return (\n          <div\n            ref={(el) => setRefs(el, tabName)}\n            class={[\n              ns.e('item'),\n              ns.is(rootTabs.props.tabPosition),\n              ns.is('active', pane.active),\n              ns.is('disabled', disabled),\n              ns.is('closable', closable),\n              ns.is('focus', isFocus.value),\n            ]}\n            id={`tab-${tabName}`}\n            key={`tab-${uid}`}\n            aria-controls={`pane-${tabName}`}\n            role=\"tab\"\n            aria-selected={pane.active}\n            tabindex={tabindex}\n            onFocus={() => setFocus()}\n            onBlur={() => removeFocus()}\n            onClick={(ev: MouseEvent) => {\n              removeFocus()\n              emit('tabClick', pane, tabName, ev)\n            }}\n            onKeydown={(ev: KeyboardEvent) => {\n              if (\n                closable &&\n                (ev.code === EVENT_CODE.delete ||\n                  ev.code === EVENT_CODE.backspace)\n              ) {\n                emit('tabRemove', pane, ev)\n              }\n            }}\n          >\n            {...[tabLabelContent, btnClose]}\n          </div>\n        )\n      })\n\n      // By tracking the value property, we can schedule a job to re-render `TabNav` when needed.\n      // Unlike `instance.update`, the scheduler ensures the job is queued only once even if we trigger it multiple times.\n      tracker.value\n\n      return (\n        <div\n          ref={el$}\n          class={[\n            ns.e('nav-wrap'),\n            ns.is('scrollable', !!scrollable.value),\n            ns.is(rootTabs.props.tabPosition),\n          ]}\n        >\n          {scrollBtn}\n          <div class={ns.e('nav-scroll')} ref={navScroll$}>\n            {props.panes.length > 0 ? (\n              <div\n                class={[\n                  ns.e('nav'),\n                  ns.is(rootTabs.props.tabPosition),\n                  ns.is(\n                    'stretch',\n                    props.stretch &&\n                      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n                  ),\n                ]}\n                ref={nav$}\n                style={navStyle.value}\n                role=\"tablist\"\n                onKeydown={changeTab}\n              >\n                {...[\n                  !props.type ? (\n                    <TabBar\n                      ref={tabBarRef}\n                      tabs={[...props.panes]}\n                      tabRefs={tabRefsMap.value}\n                    />\n                  ) : null,\n                  tabs,\n                ]}\n              </div>\n            ) : null}\n          </div>\n        </div>\n      )\n    }\n  },\n})\n\nexport type TabNavInstance = InstanceType<typeof TabNav> & {\n  scrollToActiveTab: () => Promise<void>\n  removeFocus: () => void\n  focusActiveTab: () => void\n  scheduleRender: () => void\n  tabListRef: HTMLDivElement | undefined\n  tabBarRef: TabBarInstance | undefined\n}\n\nexport default TabNav\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}